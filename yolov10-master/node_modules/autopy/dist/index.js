import {decompress as $a0Fwg$decompress} from "@mongodb-js/zstd";
import {satisfies as $a0Fwg$satisfies} from "@renovatebot/pep440";
import {createHash as $a0Fwg$createHash} from "crypto";
import $a0Fwg$decompress1 from "decompress";
import {execa as $a0Fwg$execa} from "execa";
import $a0Fwg$fsextra, {remove as $a0Fwg$remove} from "fs-extra";
import $a0Fwg$globalcachedir from "global-cache-dir";
import {Octokit as $a0Fwg$Octokit} from "octokit";
import {join as $a0Fwg$join} from "path";
import $a0Fwg$semverfunctionscomparejs from "semver/functions/compare.js";
import $a0Fwg$semverfunctionssatisfiesjs from "semver/functions/satisfies.js";
import $a0Fwg$properlockfile from "proper-lockfile";













var $97a6f465fb8f2cc1$exports = {};
$97a6f465fb8f2cc1$exports = JSON.parse('{"name":"autopy","version":"1.1.1","description":"Library for depending on Python packages from JavaScript that will automatically manage a venv and download Python and pip dependencies.","bugs":"https://github.com/tweaselORG/autopy/issues","repository":{"type":"git","url":"https://github.com/tweaselORG/autopy.git"},"license":"MIT","contributors":[{"name":"Benjamin Altpeter","email":"hi@bn.al","url":"https://benjamin-altpeter.de"},{"name":"Lorenz Sieben","email":"me@lorenz-sieben.com","url":"https://lorenz-sieben.com"}],"type":"module","main":"dist/index.js","source":"src/index.ts","types":"dist/index.d.ts","files":["/dist"],"scripts":{"build":"parcel build","fix":"yarn eslint . --ignore-path .gitignore --ext .js,.jsx,.ts,.tsx --fix","lint":"tsc && eslint . --ignore-path .gitignore --ext .js,.jsx,.ts,.tsx && git diff --check","prepack":"rm -rf dist && yarn build && yarn typedoc","test":"echo \'TODO: No tests specified yet.\'","watch":"parcel watch"},"husky":{"hooks":{"pre-commit":"lint-staged && tsc && typedoc && git add docs"}},"lint-staged":{"*.{ts,js,tsx,jsx,css,scss,json}":["prettier --write"],"*.{ts,js,tsx,jsx}":["eslint --fix"]},"prettier":"@baltpeter/prettier-config","dependencies":{"@mongodb-js/zstd":"^1.1.0","@renovatebot/pep440":"^2.1.15","decompress":"^4.2.1","execa":"^7.1.1","fs-extra":"^11.1.1","global-cache-dir":"^5.0.0","octokit":"^2.0.14","proper-lockfile":"^4.1.2","semver":"^7.5.1"},"devDependencies":{"@baltpeter/eslint-config":"2.1.2","@baltpeter/prettier-config":"2.0.0","@baltpeter/tsconfig":"3.0.0","@parcel/packager-ts":"2.8.3","@parcel/transformer-typescript-types":"2.8.3","@types/decompress":"^4.2.4","@types/fs-extra":"^11.0.1","@types/proper-lockfile":"^4.1.2","@typescript-eslint/eslint-plugin":"5.59.6","eslint":"8.40.0","eslint-plugin-eslint-comments":"3.2.0","eslint-plugin-import":"2.27.5","husky":"4.3.7","lint-staged":"13.2.2","parcel":"2.8.3","prettier":"2.8.8","typedoc":"0.24.7","typedoc-plugin-markdown":"3.15.3","typescript":"5.0.4"},"engines":{"node":">=14.0.0"}}');


const $df9eabe9bda49ea8$var$getPythonDownloadLink = async (versionRange)=>{
    const version = versionRange ?? ">= 0";
    const targetMap = {
        darwin: {
            x64: "x86_64-apple-darwin",
            arm64: "aarch64-apple-darwin"
        },
        win32: {
            x64: "x86_64-pc-windows-msvc-shared",
            ia32: "i686-pc-windows-msvc-shared"
        },
        linux: {
            x64: "x86_64-unknown-linux-gnu",
            ia32: "i686-unknown-linux-gnu",
            arm64: "aarch64-unknown-linux-gnu"
        }
    };
    const target = targetMap[process.platform][process.arch];
    if (!target) throw new Error(`Unsupported platform: ${process.platform}-${process.arch}`);
    const octokit = new (0, $a0Fwg$Octokit)({
        userAgent: `autopy/${(0, $97a6f465fb8f2cc1$exports.version)} (https://github.com/tweaselORG/autopy)`
    });
    const releasesIterator = octokit.paginate.iterator(octokit.rest.repos.listReleases, {
        owner: "indygreg",
        repo: "python-build-standalone",
        // eslint-disable-next-line camelcase
        per_page: versionRange === undefined ? 1 : 10
    });
    for await (const { data: releases  } of releasesIterator)for (const release of releases){
        // "Casual users will likely want to use the `install_only` archive, as most users do not need the build
        // artifacts present in the `full` archive."
        const assetRegex = new RegExp(`^cpython-(?<version>\\d+\\.\\d+\\.\\d+)\\+\\d+-${target}-install_only\\.tar\\.(?<ext>gz|zst)$`);
        const asset = release.assets.map((a)=>({
                ...a,
                version: assetRegex.exec(a.name)?.groups?.["version"]
            })).sort((a, b)=>{
            if (a.version && b.version) return (0, $a0Fwg$semverfunctionscomparejs)(b.version, a.version);
            if (a.version) return -1;
            if (b.version) return 1;
            return 0;
        }).find((a)=>a.version && (0, $a0Fwg$semverfunctionssatisfiesjs)(a.version, version));
        if (asset) {
            const checksumAsset = release.assets.find((a)=>a.name === `${asset.name}.sha256`);
            return {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                version: asset.version,
                pythonUrl: asset.browser_download_url,
                checksumUrl: checksumAsset?.browser_download_url
            };
        }
    }
    throw new Error(`No release for Python ${version} found.`);
};
const $df9eabe9bda49ea8$export$83db838be0f7727 = async (versionRange)=>{
    const cacheDir = await (0, $a0Fwg$globalcachedir)("autopy");
    await (0, $a0Fwg$fsextra).ensureDir((0, $a0Fwg$join)(cacheDir, "python"));
    const releaseLock = await (0, $a0Fwg$properlockfile).lock((0, $a0Fwg$join)(cacheDir, "python"), {
        retries: 20,
        stale: 120000
    });
    // Check if we already have a Python installation that satisfies the version range.
    const existingInstallations = await (0, $a0Fwg$fsextra).readdir((0, $a0Fwg$join)(cacheDir, "python"));
    const matchingExistingVersion = existingInstallations.sort((a, b)=>(0, $a0Fwg$semverfunctionscomparejs)(b, a)).find((v)=>!versionRange || (0, $a0Fwg$semverfunctionssatisfiesjs)(v, versionRange));
    if (matchingExistingVersion) {
        const existingPythonDir = (0, $a0Fwg$join)(cacheDir, "python", matchingExistingVersion);
        if (await (0, $a0Fwg$fsextra).pathExists(process.platform === "win32" ? (0, $a0Fwg$join)(existingPythonDir, "python.exe") : (0, $a0Fwg$join)(existingPythonDir, "bin", "python3"))) {
            await releaseLock();
            return existingPythonDir;
        }
        await (0, $a0Fwg$fsextra).remove(existingPythonDir);
    }
    // Otherwise, download this Python version.
    const { version: version , pythonUrl: pythonUrl , checksumUrl: checksumUrl  } = await $df9eabe9bda49ea8$var$getPythonDownloadLink(versionRange);
    if (!checksumUrl) throw new Error(`No checksum URL for Python ${version} found.`);
    const pythonArchive = await fetch(pythonUrl).then((res)=>res.arrayBuffer());
    const expectedHash = await fetch(checksumUrl).then((res)=>res.text()).then((t)=>t.trim());
    const hash = (0, $a0Fwg$createHash)("sha256").update(Buffer.from(pythonArchive)).digest("hex");
    if (hash !== expectedHash) throw new Error(`Checksum mismatch: Expected "${expectedHash}", got "${hash}".`);
    const pythonDir = (0, $a0Fwg$join)(cacheDir, "python", version);
    await (0, $a0Fwg$fsextra).ensureDir(pythonDir);
    const tarOrTarGz = pythonUrl.endsWith(".zst") ? await (0, $a0Fwg$decompress)(Buffer.from(pythonArchive)) : Buffer.from(pythonArchive);
    await (0, $a0Fwg$decompress1)(tarOrTarGz, pythonDir, {
        strip: 1
    });
    await releaseLock();
    return pythonDir;
};
const $df9eabe9bda49ea8$var$isVenv = async (dir)=>await (0, $a0Fwg$fsextra).pathExists((0, $a0Fwg$join)(dir, "pyvenv.cfg")) && await (0, $a0Fwg$fsextra).pathExists(process.platform === "win32" ? (0, $a0Fwg$join)(dir, "Scripts", "python.exe") : (0, $a0Fwg$join)(dir, "bin", "python3"));
const $df9eabe9bda49ea8$export$e522f41234ab669a = async (options)=>{
    const cacheDir = await (0, $a0Fwg$globalcachedir)("autopy");
    const venvDir = (0, $a0Fwg$join)(cacheDir, "venv", options.name);
    await (0, $a0Fwg$fsextra).ensureDir(venvDir);
    const releaseLock = await (0, $a0Fwg$properlockfile).lock(venvDir, {
        retries: 25,
        stale: 240000
    });
    // Check whether the potentially existing venv has a matching Python version.
    if (options.pythonVersion && await (0, $a0Fwg$fsextra).pathExists(venvDir) && await $df9eabe9bda49ea8$var$isVenv(venvDir)) {
        const pyvenvCfg = await (0, $a0Fwg$fsextra).readFile((0, $a0Fwg$join)(venvDir, "pyvenv.cfg"), "utf-8");
        const venvPythonVersion = pyvenvCfg.split("\n").find((l)=>l.startsWith("version = "))?.split("=")[1]?.trim();
        if (venvPythonVersion && !(0, $a0Fwg$semverfunctionssatisfiesjs)(venvPythonVersion, options.pythonVersion)) {
            if (options.allowPythonUpgrade !== false) await (0, $a0Fwg$fsextra).remove(venvDir);
            else throw new Error(`The virtual environment "${options.name}" already exists, but has a different Python version (${venvPythonVersion}) than requested (${options.pythonVersion}) and upgrading is not allowed.`);
        }
    }
    if (!await (0, $a0Fwg$fsextra).pathExists(venvDir) || !await $df9eabe9bda49ea8$var$isVenv(venvDir)) {
        const pythonDir = await $df9eabe9bda49ea8$export$83db838be0f7727(options.pythonVersion);
        const globalPythonBinary = process.platform === "win32" ? (0, $a0Fwg$join)(pythonDir, "python.exe") : (0, $a0Fwg$join)(pythonDir, "bin", "python3");
        await (0, $a0Fwg$execa)(globalPythonBinary, [
            "-m",
            "venv",
            venvDir
        ]);
    }
    const venvPythonBinary = process.platform === "win32" ? (0, $a0Fwg$join)(venvDir, "Scripts", "python.exe") : (0, $a0Fwg$join)(venvDir, "bin", "python3");
    if (options.checkRequirements !== false) {
        // Some packages require a newer pip version than shipped by python-build-standalone (e.g.
        // https://github.com/tweaselORG/autopy/issues/5), so if the user pins a pip version, we need to install that
        // first.
        const pipVersion = options.requirements.find((r)=>r.name === "pip")?.version;
        if (pipVersion) await (0, $a0Fwg$execa)(venvPythonBinary, [
            "-m",
            "pip",
            "install",
            `pip${pipVersion}`
        ]);
        // Then, we can proceed with installing the rest of the requirements with the correct pip version.
        const installedPackages = await (0, $a0Fwg$execa)(venvPythonBinary, [
            "-m",
            "pip",
            "list",
            "--local",
            "--format",
            "json"
        ]).then((r)=>JSON.parse(r.stdout));
        const missingPackages = options.requirements.filter((r)=>r.name !== "pip" && !installedPackages.some((p)=>p.name === r.name && (0, $a0Fwg$satisfies)(p.version, r.version)));
        if (missingPackages.length > 0) await (0, $a0Fwg$execa)(venvPythonBinary, [
            "-m",
            "pip",
            "install",
            ...missingPackages.map((r)=>`${r.name}${r.version}`)
        ]);
    }
    await releaseLock();
    const venvBinDir = (0, $a0Fwg$join)(venvDir, process.platform === "win32" ? "Scripts" : "bin");
    return (file, args, options)=>(0, $a0Fwg$execa)(file, args, {
            ...options,
            env: {
                PYTHONHOME: undefined,
                VIRTUAL_ENV: venvDir,
                PATH: `${venvBinDir}${process.platform === "win32" ? ";" : ":"}${process.env["PATH"]}`,
                ...options?.env
            }
        });
};
const $df9eabe9bda49ea8$export$988f678f3faabae = async (name)=>(0, $a0Fwg$remove)((0, $a0Fwg$join)(await (0, $a0Fwg$globalcachedir)("autopy"), "venv", name));


export {$df9eabe9bda49ea8$export$83db838be0f7727 as downloadPython, $df9eabe9bda49ea8$export$e522f41234ab669a as getVenv, $df9eabe9bda49ea8$export$988f678f3faabae as removeVenv};
//# sourceMappingURL=index.js.map
