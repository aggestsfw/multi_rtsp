{"mappings":";AAeA;;;;;;GAMG;AACH,qCAAqC,MAAM,GAAG,SAAS,CAAC;AAkExD;;;;;;;;GAQG;AACH,OAAO,MAAM,+BAAsC,sBAAsB,oBAiDxE,CAAC;AAQF,wFAAwF;AACxF,0BAA0B;IACtB,2CAA2C;IAC3C,IAAI,EAAE,MAAM,CAAC;IACb,+FAA+F;IAC/F,aAAa,EAAE,sBAAsB,CAAC;IACtC,4FAA4F;IAC5F,YAAY,EAAE;QACV,0CAA0C;QAC1C,IAAI,EAAE,MAAM,CAAC;QACb;;;WAGG;QACH,OAAO,EAAE,MAAM,CAAC;KACnB,EAAE,CAAC;IAEJ;;;OAGG;IACH,iBAAiB,CAAC,EAAE,OAAO,CAAC;IAC5B;;;;OAIG;IACH,kBAAkB,CAAC,EAAE,OAAO,CAAC;CAChC,CAAC;AAEF;;;;;;;;;;;;GAYG;AACH,OAAO,MAAM,mBAA0B,WAAW,oBAsEhC,MAAM,SAAS,MAAM,EAAE,YAAY,OAAY,+CAUhE,CAAC;AAEF;;;;GAIG;AACH,OAAO,MAAM,mBAA0B,MAAM,kBAA+D,CAAC","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"import { decompress as decompressZstd } from '@mongodb-js/zstd';\nimport { satisfies as pep440Satisfies } from '@renovatebot/pep440';\nimport { createHash } from 'crypto';\nimport decompress from 'decompress';\nimport type { Options as ExecaOptions } from 'execa';\nimport { execa } from 'execa';\nimport fse, { remove } from 'fs-extra';\nimport globalCacheDir from 'global-cache-dir';\nimport { Octokit } from 'octokit';\nimport { join } from 'path';\nimport lockfile from 'proper-lockfile';\nimport semverCompare from 'semver/functions/compare.js';\nimport semverSatifies from 'semver/functions/satisfies.js';\nimport { version as autopyVersion } from '../package.json';\n\n/**\n * A semver version or range that specifies the desired Python version to download or use for a virtual environment. The\n * version or range should follow the format defined by [semver](https://www.npmjs.com/package/semver). As\n * [python-build-standalone](https://github.com/indygreg/python-build-standalone) doesn't offer all Python versions, one\n * should typically specify a range (usually a tilde or caret range). If not specified, the latest available version is\n * used.\n */\nexport type SemverVersionSpecifier = string | undefined;\n\nconst getPythonDownloadLink = async (versionRange: SemverVersionSpecifier) => {\n    const version = versionRange ?? '>= 0';\n\n    const targetMap = {\n        darwin: {\n            x64: 'x86_64-apple-darwin',\n            arm64: 'aarch64-apple-darwin',\n        },\n        win32: {\n            x64: 'x86_64-pc-windows-msvc-shared',\n            ia32: 'i686-pc-windows-msvc-shared',\n        },\n        linux: {\n            x64: 'x86_64-unknown-linux-gnu',\n            ia32: 'i686-unknown-linux-gnu',\n            arm64: 'aarch64-unknown-linux-gnu',\n        },\n    };\n    const target = targetMap[process.platform as 'win32'][process.arch as 'x64'];\n    if (!target) throw new Error(`Unsupported platform: ${process.platform}-${process.arch}`);\n\n    const octokit = new Octokit({\n        userAgent: `autopy/${autopyVersion} (https://github.com/tweaselORG/autopy)`,\n    });\n\n    const releasesIterator = octokit.paginate.iterator(octokit.rest.repos.listReleases, {\n        owner: 'indygreg',\n        repo: 'python-build-standalone',\n        // eslint-disable-next-line camelcase\n        per_page: versionRange === undefined ? 1 : 10,\n    });\n\n    for await (const { data: releases } of releasesIterator) {\n        for (const release of releases) {\n            // \"Casual users will likely want to use the `install_only` archive, as most users do not need the build\n            // artifacts present in the `full` archive.\"\n            const assetRegex = new RegExp(\n                `^cpython-(?<version>\\\\d+\\\\.\\\\d+\\\\.\\\\d+)\\\\+\\\\d+-${target}-install_only\\\\.tar\\\\.(?<ext>gz|zst)$`\n            );\n\n            const asset = release.assets\n                .map((a) => ({ ...a, version: assetRegex.exec(a.name)?.groups?.['version'] }))\n                .sort((a, b) => {\n                    if (a.version && b.version) return semverCompare(b.version, a.version);\n                    if (a.version) return -1;\n                    if (b.version) return 1;\n                    return 0;\n                })\n                .find((a) => a.version && semverSatifies(a.version, version));\n            if (asset) {\n                const checksumAsset = release.assets.find((a) => a.name === `${asset.name}.sha256`);\n                return {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    version: asset.version!,\n                    pythonUrl: asset.browser_download_url,\n                    checksumUrl: checksumAsset?.browser_download_url,\n                };\n            }\n        }\n    }\n\n    throw new Error(`No release for Python ${version} found.`);\n};\n\n/**\n * Downloads and extracts a Python installation that satisfies the given version range from\n * [python-build-standalone](https://github.com/indygreg/python-build-standalone) releases. The installation is cached\n * in a global directory and reused if possible.\n *\n * @param versionRange A semver version or range that specifies the desired Python version. If not specified, the latest\n *   available version is used.\n * @returns The path to the Python installation directory.\n */\nexport const downloadPython = async (versionRange: SemverVersionSpecifier) => {\n    const cacheDir = await globalCacheDir('autopy');\n    await fse.ensureDir(join(cacheDir, 'python'));\n\n    const releaseLock = await lockfile.lock(join(cacheDir, 'python'), { retries: 20, stale: 120000 });\n\n    // Check if we already have a Python installation that satisfies the version range.\n    const existingInstallations = await fse.readdir(join(cacheDir, 'python'));\n    const matchingExistingVersion = existingInstallations\n        .sort((a, b) => semverCompare(b, a))\n        .find((v) => !versionRange || semverSatifies(v, versionRange));\n    if (matchingExistingVersion) {\n        const existingPythonDir = join(cacheDir, 'python', matchingExistingVersion);\n        if (\n            await fse.pathExists(\n                process.platform === 'win32'\n                    ? join(existingPythonDir, 'python.exe')\n                    : join(existingPythonDir, 'bin', 'python3')\n            )\n        ) {\n            await releaseLock();\n            return existingPythonDir;\n        }\n\n        await fse.remove(existingPythonDir);\n    }\n\n    // Otherwise, download this Python version.\n    const { version, pythonUrl, checksumUrl } = await getPythonDownloadLink(versionRange);\n    if (!checksumUrl) throw new Error(`No checksum URL for Python ${version} found.`);\n\n    const pythonArchive = await fetch(pythonUrl).then((res) => res.arrayBuffer());\n    const expectedHash = await fetch(checksumUrl)\n        .then((res) => res.text())\n        .then((t) => t.trim());\n\n    const hash = createHash('sha256').update(Buffer.from(pythonArchive)).digest('hex');\n    if (hash !== expectedHash) throw new Error(`Checksum mismatch: Expected \"${expectedHash}\", got \"${hash}\".`);\n\n    const pythonDir = join(cacheDir, 'python', version);\n    await fse.ensureDir(pythonDir);\n\n    const tarOrTarGz = pythonUrl.endsWith('.zst')\n        ? await decompressZstd(Buffer.from(pythonArchive))\n        : Buffer.from(pythonArchive);\n    await decompress(tarOrTarGz, pythonDir, { strip: 1 });\n\n    await releaseLock();\n    return pythonDir;\n};\n\nconst isVenv = async (dir: string) =>\n    (await fse.pathExists(join(dir, 'pyvenv.cfg'))) &&\n    (await fse.pathExists(\n        process.platform === 'win32' ? join(dir, 'Scripts', 'python.exe') : join(dir, 'bin', 'python3')\n    ));\n\n/** Options for creating or getting a virtual environment with specific requirements. */\nexport type VenvOptions = {\n    /** The name of the virtual environment. */\n    name: string;\n    /** The Python version to use for the virtual environment. Passed to {@link downloadPython}. */\n    pythonVersion: SemverVersionSpecifier;\n    /** The list of Python packages and their versions to install in the virtual environment. */\n    requirements: {\n        /** The name of the package to install. */\n        name: string;\n        /**\n         * A [PEP 440 version specifier](https://peps.python.org/pep-0440/#version-specifiers) that defines the version\n         * of the package to install.\n         */\n        version: string;\n    }[];\n\n    /**\n     * Whether to check if the requirements are already satisfied and install them if necessary. Defaults to true. If\n     * false, the virtual environment may not have (all) the specified packages installed.\n     */\n    checkRequirements?: boolean;\n    /**\n     * Whether to allow upgrading the Python version of the virtual environment if it is already created. Defaults to\n     * true. If false, calling `getVenv()` on an existing venv with an older (non-matching) Python version will throw an\n     * error. If true, the Python version will be upgraded if necessary. This will cause the venv to be recreated.\n     */\n    allowPythonUpgrade?: boolean;\n};\n\n/**\n * Creates or gets a virtual environment with the specified Python version and requirements. Returns a function for\n * running commands in the virtual environment.\n *\n * Note: If you need a specific version of pip, you can specify that in the requirements and it will be installed before\n * all other requirements.\n *\n * @param options The options for creating or getting the virtual environment. See {@link VenvOptions}.\n *\n * @returns A function that can be used to execute Python commands in the virtual environment, with all necessary\n *   environment variables set up correctly. The function is a wrapper around\n *   [`execa`](https://github.com/sindresorhus/execa).\n */\nexport const getVenv = async (options: VenvOptions) => {\n    const cacheDir = await globalCacheDir('autopy');\n    const venvDir = join(cacheDir, 'venv', options.name);\n    await fse.ensureDir(venvDir);\n\n    const releaseLock = await lockfile.lock(venvDir, { retries: 25, stale: 240000 });\n\n    // Check whether the potentially existing venv has a matching Python version.\n    if (options.pythonVersion && (await fse.pathExists(venvDir)) && (await isVenv(venvDir))) {\n        const pyvenvCfg = await fse.readFile(join(venvDir, 'pyvenv.cfg'), 'utf-8');\n        const venvPythonVersion = pyvenvCfg\n            .split('\\n')\n            .find((l) => l.startsWith('version = '))\n            ?.split('=')[1]\n            ?.trim();\n\n        if (venvPythonVersion && !semverSatifies(venvPythonVersion, options.pythonVersion)) {\n            if (options.allowPythonUpgrade !== false) await fse.remove(venvDir);\n            else\n                throw new Error(\n                    `The virtual environment \"${options.name}\" already exists, but has a different Python version (${venvPythonVersion}) than requested (${options.pythonVersion}) and upgrading is not allowed.`\n                );\n        }\n    }\n\n    if (!(await fse.pathExists(venvDir)) || !(await isVenv(venvDir))) {\n        const pythonDir = await downloadPython(options.pythonVersion);\n        const globalPythonBinary =\n            process.platform === 'win32' ? join(pythonDir, 'python.exe') : join(pythonDir, 'bin', 'python3');\n\n        await execa(globalPythonBinary, ['-m', 'venv', venvDir]);\n    }\n\n    const venvPythonBinary =\n        process.platform === 'win32' ? join(venvDir, 'Scripts', 'python.exe') : join(venvDir, 'bin', 'python3');\n\n    if (options.checkRequirements !== false) {\n        // Some packages require a newer pip version than shipped by python-build-standalone (e.g.\n        // https://github.com/tweaselORG/autopy/issues/5), so if the user pins a pip version, we need to install that\n        // first.\n        const pipVersion = options.requirements.find((r) => r.name === 'pip')?.version;\n        if (pipVersion) await execa(venvPythonBinary, ['-m', 'pip', 'install', `pip${pipVersion}`]);\n\n        // Then, we can proceed with installing the rest of the requirements with the correct pip version.\n        const installedPackages = await execa(venvPythonBinary, [\n            '-m',\n            'pip',\n            'list',\n            '--local',\n            '--format',\n            'json',\n        ]).then((r) => JSON.parse(r.stdout) as { name: string; version: string }[]);\n        const missingPackages = options.requirements.filter(\n            (r) =>\n                r.name !== 'pip' &&\n                !installedPackages.some((p) => p.name === r.name && pep440Satisfies(p.version, r.version))\n        );\n\n        if (missingPackages.length > 0)\n            await execa(venvPythonBinary, [\n                '-m',\n                'pip',\n                'install',\n                ...missingPackages.map((r) => `${r.name}${r.version}`),\n            ]);\n    }\n\n    await releaseLock();\n\n    const venvBinDir = join(venvDir, process.platform === 'win32' ? 'Scripts' : 'bin');\n    return (file: string, args?: string[], options?: ExecaOptions) =>\n        execa(file, args, {\n            ...options,\n            env: {\n                PYTHONHOME: undefined,\n                VIRTUAL_ENV: venvDir,\n                PATH: `${venvBinDir}${process.platform === 'win32' ? ';' : ':'}${process.env['PATH']}`,\n                ...options?.env,\n            },\n        });\n};\n\n/**\n * Removes the virtual environment with the specified name.\n *\n * @param name The name of the virtual environment to remove.\n */\nexport const removeVenv = async (name: string) => remove(join(await globalCacheDir('autopy'), 'venv', name));\n"],"names":[],"version":3,"file":"index.d.ts.map","sourceRoot":"../"}